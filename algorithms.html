<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>
<body>
<h1>50 Algorithms and Data Structures Every Programmer Should Know</h1>
<p>For sure, it is very difficult to provide an exhaustive list. There are too many domains, too many fields. Data structures are also constantly evolving. Algorithmic for biophysics does not solve the same problems as the algorithmic for synchronizing trains. That list is hence there to propose a first feeling of the domain.</p>
<p>Is it worth - today - learning algorithms? I believe "yes". Certainly, there are a lot of libraries to handle these. Programming languages already propose data structures exposing a "sort()" function or graph traversing algorithms. There are also means to synchronize threads or libs to handle protocols.</p>
<p>Studying algorithms is like knowing the details behind the scenes. It is lazy, difficult and not always rewarding to learn it.</p>
<p>Here is but first a list of the books that influenced me the most:</p>
<ul>
    <li><a href="https://www-cs-faculty.stanford.edu/~knuth/aa.html"><b>Selected Papers on Analysis of Algorithms</b> by Donald Knuth (LaTeX father!)</a></li>
    <li><a href="http://mitpress.mit.edu/9780262046305/introduction-to-algorithms/"><b>Introduction to algorithms</b> by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and Clifford Stein</a></li>
    <li><a href="https://www.algorist.com/"><b>The Algorithm Design Manual, 3rd Edition</b> by Steven Skiena</a></li>
</ul>
<p>I hope, step by step, to propose a detailed view of all these algorithms and data structures. I believe that it is worth it.</p>
    <ol>
        <li><strong>Sorting Algorithms</strong>
            <ul>
                <li>Bubble Sort</li>
                <li>Selection Sort</li>
                <li>Insertion Sort</li>
                <li>Merge Sort</li>
                <li>Quick Sort</li>
            </ul>
        </li>
        <li><strong>Searching Algorithms</strong>
            <ul>
                <li>Linear Search</li>
                <li>Binary Search</li>
            </ul>
        </li>
        <li><strong>Data Structures</strong>
            <ul>
                <li>Arrays</li>
                <li>Linked Lists</li>
                <li>Stacks</li>
                <li>Queues</li>
                <li>Hash Tables (or Hash Maps)</li>
                <li>Trees (Binary Trees, Binary Search Trees, AVL Trees)</li>
                <li>Heaps (Min-Heap and Max-Heap)</li>
                <li>Graphs (BFS and DFS)</li>
            </ul>
        </li>
        <li><strong>Dynamic Programming Algorithms</strong>
            <ul>
                <li>Fibonacci Sequence</li>
                <li>Longest Common Subsequence</li>
                <li>Knapsack Problem</li>
                <li>Shortest Path Algorithms (Dijkstra's and Floyd-Warshall)</li>
            </ul>
        </li>
        <li><strong>Greedy Algorithms</strong>
                    <ul>
                        <li>Huffman Coding</li>
                        <li>Minimum Spanning Tree (Prim's and Kruskal's Algorithms)</li>
                    </ul>
                </li>
        <li><strong>Graph Algorithms</strong>
                    <ul>
                        <li>Topological Sorting</li>
                        <li>Strongly Connected Components (Kosaraju's Algorithm)</li>
                        <li>Maximum Flow (Ford-Fulkerson Algorithm)</li>
                    </ul>
                </li>
        <li><strong>String Algorithms</strong>
            <ul>
                <li>String Searching (KMP Algorithm)</li>
                <li>Edit Distance (Levenshtein Distance)</li>
                <li>Longest Common Substring</li>
            </ul>
        </li>
        <li><strong>Number Theory Algorithms</strong>
            <ul>
                <li>Sieve of Eratosthenes (Prime Number Generation)</li>
                <li>Greatest Common Divisor (Euclidean Algorithm)</li>
                <li>Modular Exponentiation</li>
            </ul>
        </li>
        <li><strong>Dynamic Data Structures</strong>
            <ul>
                <li>Dynamic Arrays</li>
                <li>Dynamic Hash Tables</li>
            </ul>
        </li>
        <li><strong>Bit Manipulation</strong>
            <ul>
                <li>Bitwise Operations</li>
                <li>Bit Counting (Counting Set Bits)</li>
                <li>Bitwise Manipulation</li>
            </ul>
        </li>
        <li><strong>Geometric Algorithms</strong>
            <ul>
                <li>Convex Hull (Graham's Scan)</li>
                <li>Line Intersection</li>
            </ul>
        </li>
        <li><strong>Probability and Statistics</strong>
            <ul>
                <li>Random Number Generation</li>
                <li>Monte Carlo Simulation</li>
            </ul>
        </li>
        <li><strong>Machine Learning Algorithms</strong>
            <ul>
                <li>Linear Regression</li>
                <li>Logistic Regression</li>
                <li>k-Nearest Neighbors (k-NN)</li>
                <li>Decision Trees</li>
                <li>Random Forests</li>
            </ul>
        </li>
        <li><strong>Parallel and Concurrent Programming</strong>
            <ul>
                <li>Parallel Sorting Algorithms (e.g., Parallel Merge Sort)</li>
                <li>Thread Synchronization (Mutexes, Semaphores)</li>
                <li>Concurrent Data Structures (e.g., Concurrent Hash Maps)</li>
            </ul>
        </li>
        <li><strong>Network Algorithms</strong>
            <ul>
                <li>Routing Algorithms (Dijkstra's, Bellman-Ford)</li>
                <li>Network Flow Algorithms (Max Flow Min Cut)</li>
            </ul>
        </li>
        <li><strong>Cryptography</strong>
            <ul>
                <li>Symmetric and Asymmetric Encryption</li>
                <li>Hash Functions (MD5, SHA-1, SHA-256)</li>
                <li>Digital Signatures</li>
            </ul>
        </li>
        <li><strong>Compression Algorithms</strong>
            <ul>
                <li>Run-Length Encoding</li>
                <li>Huffman Coding</li>
                <li>Lempel-Ziv-Welch (LZW) Compression</li>
            </ul>
        </li>
        <li><strong>Database Algorithms</strong>
            <ul>
                <li>Indexing (B-Tree, Hash Index)</li>
                <li>Query Optimization (Cost-Based Query Optimization)</li>
            </ul>
        </li>
        <li><strong>Operating System Algorithms</strong>
            <ul>
                <li>Process Scheduling Algorithms (Round Robin, Priority Scheduling)</li>
                <li>Memory Management (Page Replacement Algorithms)</li>
            </ul>
        </li>
        <li><strong>AI and Search Algorithms</strong>
            <ul>
                <li>A* Search Algorithm</li>
                <li>Minimax Algorithm (for Game Playing)</li>
                <li>Genetic Algorithms</li>
            </ul>
        </li>
    </ol>
</body>
</html>