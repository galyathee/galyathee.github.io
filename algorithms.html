<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>
<body>
<h1>50 Algorithms and Data Structures Every Programmer Should Know</h1>
<p>For sure, it is very difficult to provide an exhaustive list. There are too many domains, too many fields. Data structures are also constantly evolving. Algorithmic for biophysics does not solve the same problems as the algorithmic for synchronizing trains. That list is hence there to propose a first feeling of the domain.</p>
<p>Is it worth - today - learning algorithms? I believe "yes". Certainly, there are a lot of libraries to handle these. Programming languages already propose data structures exposing a "sort()" function or graph traversing algorithms. There are also means to synchronize threads or libs to handle protocols.</p>
<p>Studying algorithms is like knowing the details behind the scenes. It is lazy, difficult and not always rewarding to learn it.</p>
<p>Here is but first a list of the books that influenced me the most:</p>
<ul>
    <li><a href="https://www-cs-faculty.stanford.edu/~knuth/aa.html"><b>Selected Papers on Analysis of Algorithms</b> by Donald Knuth (LaTeX father!)</a></li>
    <li><a href="http://mitpress.mit.edu/9780262046305/introduction-to-algorithms/"><b>Introduction to algorithms</b> by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and Clifford Stein</a></li>
    <li><a href="https://www.algorist.com/"><b>The Algorithm Design Manual, 3rd Edition</b> by Steven Skiena</a></li>
</ul>
<p>I hope, step by step, to propose a detailed view of all these algorithms and data structures. I believe that it is worth it.</p>
<div style="width: 25%; float:left; background-color: burlywood">
    <ol>
        <li><strong>Sorting Algorithms</strong>
            <ul>
                <li>Bubble Sort</li>
                <li>Selection Sort</li>
                <li>Insertion Sort</li>
                <li>Merge Sort</li>
                <li>Quick Sort</li>
            </ul>
        </li>
        <li><strong>Searching Algorithms</strong>
            <ul>
                <li>Linear Search</li>
                <li>Binary Search</li>
            </ul>
        </li>
        <li><strong>Data Structures</strong>
            <ul>
                <li>Arrays</li>
                <li>Linked Lists</li>
                <li>Stacks</li>
                <li>Queues</li>
                <li>Hash Tables (or Hash Maps)</li>
                <li>Trees (Binary Trees, Binary Search Trees, AVL Trees)</li>
                <li>Heaps (Min-Heap and Max-Heap)</li>
                <li>Graphs (BFS and DFS)</li>
            </ul>
        </li>
        <li><strong>Dynamic Programming Algorithms</strong>
            <ul>
                <li>Fibonacci Sequence</li>
                <li>Longest Common Subsequence</li>
                <li>Knapsack Problem</li>
                <li>Shortest Path Algorithms (Dijkstra's and Floyd-Warshall)</li>
            </ul>
        </li>
        <li><strong>Greedy Algorithms</strong>
                    <ul>
                        <li>Huffman Coding</li>
                        <li>Minimum Spanning Tree (Prim's and Kruskal's Algorithms)</li>
                    </ul>
                </li>
        <li><strong>Graph Algorithms</strong>
                    <ul>
                        <li>Topological Sorting</li>
                        <li>Strongly Connected Components (Kosaraju's Algorithm)</li>
                        <li>Maximum Flow (Ford-Fulkerson Algorithm)</li>
                    </ul>
                </li>
        <li><strong>String Algorithms</strong>
            <ul>
                <li>String Searching (KMP Algorithm)</li>
                <li>Edit Distance (Levenshtein Distance)</li>
                <li>Longest Common Substring</li>
            </ul>
        </li>
        <li><strong>Number Theory Algorithms</strong>
            <ul>
                <li>Sieve of Eratosthenes (Prime Number Generation)</li>
                <li>Greatest Common Divisor (Euclidean Algorithm)</li>
                <li>Modular Exponentiation</li>
            </ul>
        </li>
        <li><strong>Dynamic Data Structures</strong>
            <ul>
                <li>Dynamic Arrays</li>
                <li>Dynamic Hash Tables</li>
            </ul>
        </li>
        <li><strong>Bit Manipulation</strong>
            <ul>
                <li>Bitwise Operations</li>
                <li>Bit Counting (Counting Set Bits)</li>
                <li>Bitwise Manipulation</li>
            </ul>
        </li>
        <li><strong>Geometric Algorithms</strong>
            <ul>
                <li>Convex Hull (Graham's Scan)</li>
                <li>Line Intersection</li>
            </ul>
        </li>
        <li><strong>Probability and Statistics</strong>
            <ul>
                <li>Random Number Generation</li>
                <li>Monte Carlo Simulation</li>
            </ul>
        </li>
        <li><strong>Machine Learning Algorithms</strong>
            <ul>
                <li style="color:red" onclick="document.getElementById('display-content').innerHTML = document.getElementById('linear-regression').innerHTML;">Linear Regression</li>
                <li>Logistic Regression</li>
                <li>k-Nearest Neighbors (k-NN)</li>
                <li>Decision Trees</li>
                <li>Random Forests</li>
            </ul>
        </li>
        <li><strong>Parallel and Concurrent Programming</strong>
            <ul>
                <li>Parallel Sorting Algorithms (e.g., Parallel Merge Sort)</li>
                <li>Thread Synchronization (Mutexes, Semaphores)</li>
                <li>Concurrent Data Structures (e.g., Concurrent Hash Maps)</li>
            </ul>
        </li>
        <li><strong>Network Algorithms</strong>
            <ul>
                <li>Routing Algorithms (Dijkstra's, Bellman-Ford)</li>
                <li>Network Flow Algorithms (Max Flow Min Cut)</li>
            </ul>
        </li>
        <li><strong>Cryptography</strong>
            <ul>
                <li>Symmetric and Asymmetric Encryption</li>
                <li>Hash Functions (MD5, SHA-1, SHA-256)</li>
                <li>Digital Signatures</li>
            </ul>
        </li>
        <li><strong>Compression Algorithms</strong>
            <ul>
                <li>Run-Length Encoding</li>
                <li>Huffman Coding</li>
                <li>Lempel-Ziv-Welch (LZW) Compression</li>
            </ul>
        </li>
        <li><strong>Database Algorithms</strong>
            <ul>
                <li>Indexing (B-Tree, Hash Index)</li>
                <li>Query Optimization (Cost-Based Query Optimization)</li>
            </ul>
        </li>
        <li><strong>Operating System Algorithms</strong>
            <ul>
                <li>Process Scheduling Algorithms (Round Robin, Priority Scheduling)</li>
                <li>Memory Management (Page Replacement Algorithms)</li>
            </ul>
        </li>
        <li><strong>AI and Search Algorithms</strong>
            <ul>
                <li>A* Search Algorithm</li>
                <li>Minimax Algorithm (for Game Playing)</li>
                <li>Genetic Algorithms</li>
            </ul>
        </li>
    </ol>
</div>
<div id="display-content" style="width: 75%; float:right; background-color: darksalmon"></div>


<div id="linear-regression" hidden>
    <p>The linear regression algorithm is a machine learning technique used to model the linear relationship between a dependent variable (or target) and one or more independent variables (or features). It is primarily used for regression tasks, meaning it predicts a numerical value based on other numerical data. The goal of linear regression is to find the best straight line (or hyperplane) that fits the data.</p>

    <p>The general equation for linear regression with a single independent variable is as follows:</p>

    <code>y=mx+by=mx+b</code>

    <p>Where:<br/>
    yy is the dependent variable we are trying to predict.<br/>
    xx is the independent variable (feature).<br/>
    mm is the slope of the regression line.<br/>
        bb is the y-intercept.</p>

    <p>The objective of the linear regression algorithm is to find the optimal values of mm and bb to minimize the prediction error. One of the commonly used methods to solve this problem is the least squares method, which involves minimizing the sum of the squares of the differences between actual values and values predicted by the model.</p>

    <p>Here is a simple example of a linear regression algorithm in <b>Lua</b>. In this example, we'll use a small dataset to perform linear regression and predict a value yy based on a value xx.</p>
<pre>
    <code>
        -- Sample data (x and y)
local x = {1, 2, 3, 4, 5}
local y = {2, 4, 5, 4, 5}

-- Calculate the means of x and y values
local n = #x
local sum_x = 0
local sum_y = 0
for i = 1, n do
    sum_x = sum_x + x[i]
    sum_y = sum_y + y[i]
end
local mean_x = sum_x / n
local mean_y = sum_y / n

-- Calculate regression coefficients
local numerator = 0
local denominator = 0
for i = 1, n do
    numerator = numerator + (x[i] - mean_x) * (y[i] - mean_y)
    denominator = denominator + (x[i] - mean_x)^2
end
local m = numerator / denominator
local b = mean_y - m * mean_x

-- Prediction function
function predict(x_value)
    return m * x_value + b
end

-- Use the prediction function
local x_to_predict = 6
local y_predicted = predict(x_to_predict)
print("For x =", x_to_predict, "the prediction is y =", y_predicted)

    </code>
</pre>
    <p>Tested on that online compiler <a href="https://www.lua.org/cgi-bin/demo">LUA Online Compiler</a></p>
    <p>Obtained result:</p>
    <code>For x =	6	the prediction is y =	5.8</code>
</div>

</body>
</html>
